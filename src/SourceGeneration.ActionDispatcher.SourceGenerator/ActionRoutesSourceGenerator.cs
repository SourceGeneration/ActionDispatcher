using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace SourceGeneration.ActionDispatcher.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class ActionRoutesSourceGenerator : IIncrementalGenerator
{
    public const string RootNamespace = "SourceGeneration.ActionDispatcher";
    public const string HandleAttribute = $"{RootNamespace}.ActionHandlerAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            HandleAttribute,
            predicate: static (node, token) =>
            {
                if (node is not MethodDeclarationSyntax method
                    || method.IsAbstract()
                    || !method.IsPublicOrInternal()
                    || method.TypeParameterList != null
                    || method.ParameterList.Parameters.Count == 0)
                {
                    return false;
                }

                if (node.Parent is ClassDeclarationSyntax or InterfaceDeclarationSyntax or RecordDeclarationSyntax)
                {
                    return true;
                }

                return false;
            },
            transform: static (context, token) =>
            {
                return (MethodDeclarationSyntax)context.TargetNode;
            });

        var source = methodDeclarations.Collect().Combine(context.CompilationProvider);

        context.RegisterSourceOutput(source, static (sourceContext, source) =>
        {
            CancellationToken cancellationToken = sourceContext.CancellationToken;
            ImmutableArray<MethodDeclarationSyntax> methods = source.Left;
            Compilation compilation = source.Right;

            List<string> instanceRegisters = [];
            List<string> methodRegisters = [];

            foreach (var group in methods.GroupBy(c => c.SyntaxTree))
            {
                SyntaxTree syntaxTree = group.Key;
                SemanticModel model = compilation.GetSemanticModel(syntaxTree);
                foreach (var methodGroup in group.GroupBy(x => x.Parent))
                {
                    if (model.GetDeclaredSymbol(methodGroup.Key!, cancellationToken) is not INamedTypeSymbol parent)
                        continue;

                    string typeName = parent.GetFullName();
                    bool registed = false;

                    foreach (var method in methodGroup)
                    {
                        if (model.GetDeclaredSymbol(method, cancellationToken) is not IMethodSymbol methodSymbol)
                            continue;

                        if (!method.IsStatic() && !registed)
                        {
                            if (parent.Constructors.Length == 1)
                            {
                                var constructor = parent.Constructors[0];
                                var parameters = constructor.Parameters.Select(x => x.Type.GetFullName()).ToArray();
                                var expression = $"arguments => new {typeName}({string.Join(", ", parameters.Select((x, i) => $"({x})arguments[{i}]"))})";
                                instanceRegisters.Add($"global::{RootNamespace}.ActionRoutes.RegisterType(typeof({typeName}), [{string.Join(", ", parameters.Select(x => $"typeof({x})"))}], {expression});");
                            }
                            registed = true;
                        }

                        methodRegisters.Add(Parse(methodSymbol, typeName));

                        cancellationToken.ThrowIfCancellationRequested();
                    }
                }
            }

            if (methodRegisters.Count == 0)
                return;

            CSharpCodeBuilder builder = new();

            builder.AppendAutoGeneratedComment();
            builder.AppendBlock("internal static class ___ActionRoutesInitializer", () =>
            {
                builder.AppendLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
                builder.AppendBlock("public static void Initialize()", () =>
                {
                    foreach (var instance in instanceRegisters)
                    {
                        builder.AppendLine(instance);
                    }
                    foreach (var method in methodRegisters)
                    {
                        builder.AppendLine(method);
                    }
                });

            });

            sourceContext.AddSource($"{RootNamespace}.___ActionRoutesInitializer.g.cs", builder.ToString());
        });
    }

    static string Parse(IMethodSymbol method, string baseTypeName)
    {
        var parameters = method.Parameters;

        bool async = false;
        var returnType = method.ReturnType;
        if (returnType is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType && namedTypeSymbol.BaseType != null)
        {
            returnType = namedTypeSymbol.BaseType;
        }
        string returnTypeName = returnType.ToDisplayString();
        if (returnTypeName == "System.Threading.Tasks.Task" || returnTypeName == "System.Threading.Tasks.ValueTask")
        {
            async = true;
        }

        string[] parameterTypes = new string[parameters.Length + 1];
        string[] arguments = new string[parameters.Length + 1];

        string instance = method.IsStatic ? baseTypeName : $"(({baseTypeName})arguments[0])";
        parameterTypes[0] = method.IsStatic ? "null" : $"typeof({baseTypeName})";
        for (int i = 1; i <= parameters.Length; i++)
        {
            var typename = parameters[i - 1].Type.GetFullName();
            parameterTypes[i] = $"typeof({typename})";
            arguments[i] = typename == "object" ? $"arguments[{i}]" : $"({typename})arguments[{i}]";
        }

        if (async)
        {
            return $"global::{RootNamespace}.ActionRoutes.RegisterMethod([{string.Join(", ", parameterTypes)}], arguments => {instance}.{method.Name}({string.Join(", ", arguments.Skip(1))}));";
        }
        else
        {
            return $"global::{RootNamespace}.ActionRoutes.RegisterMethod([{string.Join(", ", parameterTypes)}], arguments => {{ {instance}.{method.Name}({string.Join(", ", arguments.Skip(1))}); return global::System.Threading.Tasks.Task.CompletedTask; }});";
        }

    }

}
